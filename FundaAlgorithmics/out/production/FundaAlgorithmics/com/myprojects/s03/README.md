## 归并排序

1. 递归实现时间复杂度

$$
T(N)=a*T(\frac{N}{b})+O(N^d) \\
\begin{cases}
\log_ba>d & O(N^{\log_ba}) \\
\log_ba<d & O(N^d) \\
\log_ba=d & O(N^d * logN)
\end{cases}
$$

> a=2,b=2,d=1
>
> 符合第三个条件，时间复杂度为O(N * logN)，空间复杂度O(N)

2. 面试题

> 在一个数组中，一个数左边比它小的数的总和，叫数的小和，所有数的小和累加起来，叫数组小和。求数组小和。
>
> 例子： [1,3,4,2,5] 
>
> 1左边比1小的数：没有
>
> 3左边比3小的数：1
>
> 4左边比4小的数：1、3
>
> 2左边比2小的数：1
>
> 5左边比5小的数：1、3、4、 2
>
> 所以数组的小和为1+1+3+1+1+3+4+2=16 

> 使用归并排序方法实现



## 快速排序

1. 快速排序1.0

> 在arr[L..R]范围上，进行快速排序的过程：
>
> 1）用arr[R]对该范围做partition，<= arr[R]的数在左部分并且保证arr[R]最后来到左部分的最后一个位置，记为M； <= arr[R]的数在右部分（arr[M+1..R]）
>
> 2）对arr[L..M-1]进行快速排序(递归)
>
> 3）对arr[M+1..R]进行快速排序(递归)
>
> 因为每一次partition都会搞定一个数的位置且不会再变动，所以排序能完成

2. 快速排序2.0

> 在arr[L..R]范围上，进行快速排序的过程：
>
> 1）用arr[R]对该范围做partition，< arr[R]的数在左部分，== arr[R]的数中间，>arr[R]的数在右部分。假设== arr[R]的数所在范围是[a,b]
>
> 2）对arr[L..a-1]进行快速排序(递归)
>
> 3）对arr[b+1..R]进行快速排序(递归)
>
> 因为每一次partition都会搞定一批数的位置且不会再变动，所以排序能完成

3. 快速排序3.0

> 在arr[L..R]范围上，进行快速排序的过程：
>
> 1）在这个范围上，随机选一个数记为num，
>
> 1）用num对该范围做partition，< num的数在左部分，== num的数中间，>num的数在右部分。假设== num的数所在范围是[a,b]
>
> 2）对arr[L..a-1]进行快速排序(递归)
>
> 3）对arr[b+1..R]进行快速排序(递归)
>
> 因为每一次partition都会搞定一批数的位置且不会再变动，所以排序能完成

4. 时间复杂度

> 1）通过分析知道，划分值越靠近中间，性能越好；越靠近两边，性能越差
>
> 2）随机选一个数进行划分的目的就是让好情况和差情况都变成概率事件
>
> 3）把每一种情况都列出来，会有每种情况下的时间复杂度，但概率都是1/N
>
> 4）那么所有情况都考虑，时间复杂度就是这种概率模型下的长期期望！
>
> 时间复杂度O(N*logN)，额外空间复杂度O(logN)都是这么来的。